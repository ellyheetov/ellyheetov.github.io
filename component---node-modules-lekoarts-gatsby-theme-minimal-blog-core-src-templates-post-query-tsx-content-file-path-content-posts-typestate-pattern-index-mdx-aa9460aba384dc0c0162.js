"use strict";(self.webpackChunkminimal_blog=self.webpackChunkminimal_blog||[]).push([[5],{7169:function(e,n,t){var l=t(6540),a=t(4794),c=t(7533);n.A=e=>{let{title:n="",description:t="",pathname:r="",image:i="",children:o=null,canonicalUrl:u=""}=e;const s=(0,c.A)(),{siteTitle:m,siteTitleAlt:d,siteUrl:E,siteDescription:p,siteImage:g,author:k,siteLanguage:h}=s,f={title:n?`${n} | ${m}`:d,description:t||p,url:`${E}${r||""}`,image:`${E}${i||g}`};return l.createElement(l.Fragment,null,l.createElement("html",{lang:h}),l.createElement("title",null,f.title),l.createElement("meta",{name:"description",content:f.description}),l.createElement("meta",{name:"image",content:f.image}),l.createElement("meta",{property:"og:title",content:f.title}),l.createElement("meta",{property:"og:url",content:f.url}),l.createElement("meta",{property:"og:description",content:f.description}),l.createElement("meta",{property:"og:image",content:f.image}),l.createElement("meta",{property:"og:type",content:"website"}),l.createElement("meta",{property:"og:image:alt",content:f.description}),l.createElement("meta",{name:"twitter:card",content:"summary_large_image"}),l.createElement("meta",{name:"twitter:title",content:f.title}),l.createElement("meta",{name:"twitter:url",content:f.url}),l.createElement("meta",{name:"twitter:description",content:f.description}),l.createElement("meta",{name:"twitter:image",content:f.image}),l.createElement("meta",{name:"twitter:image:alt",content:f.description}),l.createElement("meta",{name:"twitter:creator",content:k}),l.createElement("meta",{name:"gatsby-theme",content:"@lekoarts/gatsby-theme-minimal-blog"}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"32x32",href:(0,a.withPrefix)("/favicon-32x32.png")}),l.createElement("link",{rel:"icon",type:"image/png",sizes:"16x16",href:(0,a.withPrefix)("/favicon-16x16.png")}),l.createElement("link",{rel:"apple-touch-icon",sizes:"180x180",href:(0,a.withPrefix)("/apple-touch-icon.png")}),u?l.createElement("link",{rel:"canonical",href:u}):null,o)}},7715:function(e,n,t){var l=t(557),a=t(6540),c=t(4794),r=t(3601),i=t(2174);n.A=e=>{let{tags:n}=e;const{tagsPath:t,basePath:o}=(0,r.A)();return(0,l.Y)(a.Fragment,null,n.map(((e,n)=>(0,l.Y)(a.Fragment,{key:e.slug},!!n&&", ",(0,l.Y)(c.Link,{sx:e=>{var n;return{...null===(n=e.styles)||void 0===n?void 0:n.a}},to:(0,i.A)(`/${o}/${t}/${e.slug}`)},e.name)))))}},8154:function(e,n,t){t.r(n),t.d(n,{Head:function(){return g},default:function(){return h}});var l=t(6540),a=t(8453);function c(e){const n=Object.assign({h1:"h1",blockquote:"blockquote",p:"p",pre:"pre",code:"code",h2:"h2",h3:"h3",ul:"ul",li:"li",strong:"strong",ol:"ol",a:"a"},(0,a.RP)(),e.components);return l.createElement(l.Fragment,null,l.createElement(n.h1,null,"Typestate Design Pattern"),"\n",l.createElement(n.blockquote,null,"\n",l.createElement(n.p,null,"the new Design Pattern in Swift 5.9"),"\n"),"\n",l.createElement(n.p,null,"Typestate 디자인 패턴은 객체의 상태를 타입으로 표현하고, 상태 전환을 타입 시스템으로 관리하는 강력한 디자인 패턴이다."),"\n",l.createElement(n.p,null,"회전식 개찰구를 예로 들어보자."),"\n",l.createElement("center",null,l.createElement("img",{src:"https://swiftology.io/turnstile.png"})),"\n",l.createElement(n.p,null,"잠긴 개찰구에 동전을 넣고 밀면 개찰구가 열린다. 한번열리면 다시 닫힘 상태로 돌아간다."),"\n",l.createElement("center",null,l.createElement("img",{src:"https://swiftology.io/turnstile-state-machine.png"})),"\n",l.createElement(n.p,null,"동전을 넣고 push 하는 과정을 코드로 풀어보면 다음과 같다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"struct Turnstile {\n  enum State {\n    case locked\n    case unlocked\n  }\n  \n  private var state: State = .locked\n  private(set) var coins: Int = 0\n\n  mutating func insertCoin() {\n    guard state == .locked else { return }\n    \n    coins += 1\n    state = .unlocked\n  }\n  \n  mutating func push() {\n  \tstate = .locked\n\t}\n}\n")),"\n",l.createElement("br"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"var turnstile = Turnstile() // locked\nturnstile.insertCoin() // unlocked\nturnstile.push()\n")),"\n",l.createElement(n.p,null,"이와 같이 코드가 예쁘게만 돌아가지 않는다.",l.createElement("br"),"\n만약 돈을 넣고 밀지 않았다가, 한번더 돈 넣고 미는 상황이 발생한다면?",l.createElement("br"),"\n만약 돈을 넣지 않고 미는 상황이 발생한다면?",l.createElement("br")),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"var turnstile = Turnstile() // locked\n\nturnstile.insertCoin() // unlocked\nturnstile.insertCoin() // ❌ ERROR: Can't insert coins when unlocked\n\nturnstile.push() // locked\nturnstile.push() // ❌ ERROR: Can't push when locked\n")),"\n",l.createElement(n.p,null,"이 경우 컴파일 에러가 나지는 않지만, 의도한 대로 동작하지는 않는다."),"\n",l.createElement(n.h2,null,"Typestae Driven Pattern 의 출두"),"\n",l.createElement(n.p,null,"로직적인 이슈가 있다면 컴파일 단에서 확인하겠다는 취지의 typestate driven pattern 이 나오게 된 것!"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"extension Turnstile where State == Locked {\n    func insertCoin() -> Turnstile<Unlocked> { // insertCoin operation can only be performed on `Turnstile<Locked>`\n        // guard state == .locked else { return }\n        return Turnstile<Unlocked>(coins: coins + 1)\n    }\n}\n")),"\n",l.createElement(n.p,null,"위와 같이 Turnstile 을 생성하면 Unlocked 상태 일 때에만 insertCoin 함수를 호출할 수 있다. guard 문으로 감싸서 현재 상태 state 를 확인할 필요가 없다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"extension Turnstile where State == Unlocked {\n    func push() -> Turnstile<Locked> {\n        return Turnstile<Locked>(coins: coins)\n    }\n}\n")),"\n",l.createElement(n.p,null,"마찬가지로 push 는 Locked 상태에서만 유효한 메소드가 된다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"unlocked.insertCoin() // ❌ ERROR: Can't insert coin into an unlocked turnstile\n\nlocked = unlocked.push()\nlocked.push() // ❌ ERROR: Can't push a locked turnstile\n\n")),"\n",l.createElement(n.p,null,"컴파일 에러를 발생함으로써 비정상적인 동작은 수행하지 않도록 보장할 수 있다."),"\n",l.createElement(n.h2,null,"하지만 여전히 문제가 있다."),"\n",l.createElement(n.p,null,"하지만 여기에도 문제는 있다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"var locked = Turnstile<Locked>()\nvar unlocked = locked.insertCoin()\nunlocked = locked.insertCoin()\n")),"\n",l.createElement(n.h3,null,"1. 값 타입의 복사 문제 (Copy semantics)"),"\n",l.createElement(n.p,null,"Turnstile은 구조체로 정의되어있기 때문에 ",l.createElement(n.code,null,"insertCoin()")," 메서드를 호출할 때마다 locked 의 복사본이 생성된다. 즉, locked 의 복사본에 대한 결과를 unlocked에 할당한다. 문제는 locked 는 여전히 초기 상태의 객체로 유지 된다는 것이다."),"\n",l.createElement(n.p,null,"따라서, 이후에 ",l.createElement(n.code,null,"locked.insertCoin()"),"을 다시 호출해도 locked는 여전히 복사된 상태로 작업하므로, 예상과 다른 동작이 발생한다."),"\n",l.createElement(n.h3,null,"2. 상태 전환이 제대로 적용되지 않음"),"\n",l.createElement(n.p,null,"Typestate 패턴의 핵심은 각 상태를 명확히 정의하고 허용된 전환만 가능하게 제한하는 것이다. 그러나 위 코드에서는 locked의 상태가 계속 바뀌지 않고 원래 상태로 남아있기 때문에 상태 전환이 제대로 적용되지 않는다."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.code,null,"locked.insertCoin()")," 은 새로운",l.createElement(n.code,null,"unlocked")," 를 반환하지만, ",l.createElement(n.code,null,"locked")," 자체는 여전히 Locked 상태이다."),"\n",l.createElement(n.li,null,"다시 ",l.createElement(n.code,null,"locked.insertCoin()")," 을 호출하면, locked는 여전히 Locked 상태로 시작한다."),"\n",l.createElement(n.li,null,"결과적으로 Locked는 상태 전환 로직이 제대로 동작하지 않으며, 코드는 실제 상태를 반영하지 못한다."),"\n"),"\n",l.createElement(n.h2,null,"어떻게 해결해?"),"\n",l.createElement(n.h3,null,"구조체를 클래스로 바꾸면?"),"\n",l.createElement(n.p,null,"직관적으로는 ",l.createElement(n.code,null,"Turnstile")," 유형을 구조체 대신 클래스로 선언하는 방법이 있다. 상태를 전환할 때마다 새로운 복사본 객체를 생성하는 대신 동일한 인스턴스를 계속 가리키고 최신 상태를 관찰하는 것이다."),"\n",l.createElement(n.p,null,"안타깝게도, 아래 두가지 문제가 존재한다."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Typestate 패턴에서는 각 상태를 독립적인 타입으로 표현해야 한다.","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"클래스는 동일한 메모리를 참조하기 때문에, 서로 다른 타입의 상태를 한 객체로표현할 수 없다."),"\n"),"\n"),"\n",l.createElement(n.li,null,"참조 방식은 Race Condition (경합 상태) 같은 문제를 발생할 수 있다.","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"예를 들어서 여러 스레드에서 같은 객체를 동시에 수정하면 예층 불가능한 오류가 발생할 수 있다."),"\n"),"\n"),"\n"),"\n",l.createElement(n.h3,null,"actor 를 사용하면?"),"\n",l.createElement(n.p,null,"구조체에서 클래스나 actor 로 바꾸면 상태전환이 비동기적으로 처리되어야 하며, 시스템이 더 복잡해 질 수 있다."),"\n",l.createElement(n.h3,null,"그럼 어떻게 해? swift 5.9의 메모리 소유 모델"),"\n",l.createElement(n.p,null,"원하는 결과가 뭔지 다시 생각해보자. 상태 전환에서 locked의 상태를 업데이트하고, 이전 상태를 사용할 수 없도록 설계해야 한다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"var locked = Turnstile<Locked>()\nvar unlocked = locked.insertCoin()\n// 이후 locked는 더 이상 유효하지 않음\n")),"\n",l.createElement(n.p,null,"이를 위해서는 상태 전환 후 이전 상태를 사용할 수 없도록 해야 한다."),"\n",l.createElement(n.p,null,"이게 바로 Swift 5.9의 메모리 소유 모델이 나오게 된 이유이다! 이를 통해 Typestate 패턴에 맞는 설계를 구현할 수 있다."),"\n",l.createElement(n.h2,null,"Noncopyable State"),"\n",l.createElement(n.p,null,"swift 5.9 에서는 Noncopyable 타입 (복사 불가능한 타입)을 도입 했으며 'move-only' 타입으로 불리기도 한다. 이 타입은 구조체나 열거형에 ",l.createElement(n.code,null,"~Copyable")," ('~' : NOT 을 의미) 키워드를 사용하여 정의한다. 이렇게 정의된 타입은 값이 복사되지 않음을 컴파일러에게 알리는 역할을 한다."),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"Notcopyable 타입이란?")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"특정 값이 복사되지 않도록 제한"),"\n",l.createElement(n.li,null,"복사를 막음으로써 값을 안전하게 한 번만 사용하도록 강제"),"\n"),"\n",l.createElement(n.h3,null,"consuming 함수란?"),"\n",l.createElement(n.p,null,"consuming 함수란 값을 '소모' 하는 함수로, 호출 이후 원래 값을 더이상 사용할 수 없게 만든다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"func changeState(_ state: consuming State) { ... }\n")),"\n",l.createElement(n.p,null,"이 함수에 값을 전달하면, 해당 값은 함수 내부에서만 사용되고 호출 이후에는 접근할 수 없다."),"\n",l.createElement(n.p,null,"Typestate 패턴에서는 상태 전환 후 이전 상태를 무효화 해야한다."),"\n",l.createElement(n.p,null,"Noncopyable 타입과 consuming 함수를 활용하면, 상태 전환 후 이전 상태를 강제로 사용할 수 없도록 컴파일러가 보장한다. 이를 통해 Typestate 패턴의 안전성과 일관성을 강화할 수 있다."),"\n",l.createElement(n.p,null,"Turnstile 예시로 다시 돌아와 보자."),"\n",l.createElement(n.p,null,"Turnstile 을 ",l.createElement(n.code,null,"~Copyable")," 타입으로 정의한다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"struct Turnstile<State>: ~Copyable {\n  ...\n}\n")),"\n",l.createElement(n.p,null,"모든 함수를 consuming 함수로 변경한다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"extension Turnstile where State == Locked {\n  consuming func insertCoin() -> Turnstile<Unlocked> {\n    Turnstile<Unlocked>(coins: coins + 1)\n  }\n}\n\nextension Turnstile where State == Unlocked {\n  consuming func push() -> Turnstile<Locked> {\n    Turnstile<Locked>(coins: coins)\n  }\n}\n")),"\n",l.createElement(n.p,null,"처음 위의 코드를 다시 실행하게 되면 컴파일 에러가 발생한다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,null,"let locked = Turnstile<Locked>()\nvar unlocked = locked.insertCoin()\nunlocked = locked.insertCoin() // ❌ ERROR: 'locked' consumed more than once\n")),"\n",l.createElement(n.p,null,"Unlocked 상태로 전환하자마자 ",l.createElement(n.code,null,"locked")," 변수의 수명이 종료되어 재사용이 불가하기 때문이다."),"\n",l.createElement(n.h2,null,"정상 코드"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"var locked = Turnstile<Locked>()\nvar unlocked = locked.insertCoin()\n// assigning new locked value\nlocked = unlocked.push()\nunlocked = locked.insertCoin() // assigning next state\nunlocked.coins // 2\n")),"\n",l.createElement(n.ol,null,"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"초기 상태 설정"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"var locked = Turnstile<Locked>()\n")),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"동전을 넣어 상태 전환"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"var unlocked = locked.insertCoin()\n")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.code,null,"locked.insertCoin()")," 메서드를 호출하면, Turnstile이 Locked 상태에서 Unlocked 상태로 전환된다."),"\n",l.createElement(n.li,null,"이 메서드의 결과로 반환된 새 상태를 unlocked에 할당한다.","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"unlocked는 이제 ",l.createElement(n.code,null,"Turnstile<Unlocked>")," 타입을 가지며, “잠금 해제된 상태”이다."),"\n"),"\n"),"\n",l.createElement(n.li,null,"이 시점에서 locked는 여전히 이전 상태(Locked)를 유지하고 있다."),"\n"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"다시 잠금 상태로 전환"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"locked = unlocked.push()\n")),"\n",l.createElement(n.p,null,l.createElement(n.code,null,"locked.insertCoin()")," 메서드를 호출하면, Turnstile이 Locked 상태에서 Unlocked 상태로 전환된다."),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"이 메서드의 결과로 반환된 새 상태를 unlocked에 할당한다."),"\n",l.createElement(n.li,null,"unlocked는 이제 ",l.createElement(n.code,null,"Turnstile<Unlocked>")," 타입을 가지며, “잠금 해제된 상태”이다."),"\n",l.createElement(n.li,null,"이 시점에서 locked는 여전히 이전 상태(Locked)를 유지하고 있다."),"\n"),"\n"),"\n",l.createElement(n.li,null,"\n",l.createElement(n.p,null,"다음 상태로 전환"),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"unlocked = locked.insertCoin()\n")),"\n"),"\n"),"\n",l.createElement(n.p,null,"체인형 operation 도 가능하다."),"\n",l.createElement(n.pre,null,l.createElement(n.code,{className:"language-swift"},"var turnstile = Turnstile<Locked>()\n  .insertCoin()\n  .push()\n  .insertCoin()\n  .push()\n  \nturnstile.coins // 2\n\nturnstile\n  .insertCoin()\n  .insertCoin() // ❌ ERROR: can't insertCoin again\n  .push()\n  .push() // ❌ ERROR: can't push again\n")),"\n",l.createElement(n.h1,null,"정리"),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"Typestate 패턴은 객체의 상태를 명확히 정의하고, 상태에 따라 가능한 동작을 제한하는 디자인 패턴이다."),"\n",l.createElement(n.li,null,"특징","\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,"설계 : 객체의 상태를 타입으로 표현한다."),"\n",l.createElement(n.li,null,"안전성 : 컴파일 타임에 허용되지 않는 동작을 방지한다."),"\n",l.createElement(n.li,null,"상태 전환 : 상태 변경 후 이전 상태는 더이상 사용할 수 없다. 상태 전환은 새 객체를 생성하는 방식으로 처리한다."),"\n",l.createElement(n.li,null,"명확한 제어 : 각 상태는 고유한 기능만 가지므로, 불필요한 복잡성을 줄인다."),"\n"),"\n"),"\n",l.createElement(n.li,null,"Swift 5.9 Noncopyable 타입: 상태 전환 후 잘못된 상태 재사용을 방지한다."),"\n"),"\n",l.createElement(n.p,null,l.createElement(n.strong,null,"참고")),"\n",l.createElement(n.ul,null,"\n",l.createElement(n.li,null,l.createElement(n.a,{href:"https://swiftology.io/articles/typestate/#what-is-a-typestate-design-pattern"},"https://swiftology.io/articles/typestate/#what-is-a-typestate-design-pattern")),"\n"))}var r=function(e){void 0===e&&(e={});const{wrapper:n}=Object.assign({},(0,a.RP)(),e.components);return n?l.createElement(n,e,l.createElement(c,e)):c(e)},i=t(557),o=t(6835),u=t(3328),s=t(7715),m=t(7169);var d=e=>{let{post:n}=e;return null};const E=["16px","8px","4px"].map((e=>`rgba(0, 0, 0, 0.1) 0px ${e} ${e} 0px`));var p=e=>{let{data:{post:n},children:t}=e;return(0,i.Y)(u.A,null,(0,i.Y)(o.DZ,{as:"h1",variant:"styles.h1"},n.title),(0,i.Y)("p",{sx:{color:"secondary",mt:3,a:{color:"secondary"},fontSize:[1,1,2]}},(0,i.Y)("time",null,n.date),n.tags&&(0,i.Y)(l.Fragment,null," — ",(0,i.Y)(s.A,{tags:n.tags})),n.timeToRead&&" — ",n.timeToRead&&(0,i.Y)("span",null,n.timeToRead," min read")),(0,i.Y)("section",{sx:{my:5,".gatsby-resp-image-wrapper":{my:[4,4,5],borderRadius:"4px",boxShadow:E.join(", "),".gatsby-resp-image-image":{borderRadius:"4px"}},variant:"layout.content"}},t),(0,i.Y)(d,{post:n}))};const g=e=>{var n,t,l;let{data:{post:a}}=e;return(0,i.Y)(m.A,{title:a.title,description:a.description?a.description:a.excerpt,image:a.banner?null===(n=a.banner)||void 0===n||null===(t=n.childImageSharp)||void 0===t||null===(l=t.resize)||void 0===l?void 0:l.src:void 0,pathname:a.slug,canonicalUrl:a.canonicalUrl})};function k(e){let{...n}=e;return l.createElement(p,n)}function h(e){return l.createElement(k,e,l.createElement(r,e))}}}]);
//# sourceMappingURL=component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx-content-file-path-content-posts-typestate-pattern-index-mdx-aa9460aba384dc0c0162.js.map